{"meta":{"title":"tyale chen | 最是空灵的守望宛若掌心化不开的温柔","subtitle":null,"description":null,"author":"tyale chen","url":"https://tyale.github.io"},"pages":[],"posts":[{"title":"水边","slug":"水边","date":"2018-01-18T15:33:43.000Z","updated":"2018-01-18T15:44:42.276Z","comments":true,"path":"2018/01/18/水边/","link":"","permalink":"https://tyale.github.io/2018/01/18/水边/","excerpt":"轻舟与岸从我夕阳的目光中消失眼前的秋雨 与我相融一片又一片的宁静见证我固执地等待 一如水边的青草萋萋复萋萋","text":"轻舟与岸从我夕阳的目光中消失眼前的秋雨 与我相融一片又一片的宁静见证我固执地等待 一如水边的青草萋萋复萋萋 这空濛的水域隔我们西风与岸的距离竟无缘越渡而我怅惘的守望已褪色 成斑驳的身影阳光亦老去 水边如此安静啊我吹响一支竹笛 却惹得水鸟的歌声在天空回荡反复诉说谁的爱情 盲眼的城市也觉察了秘密是谁设置的悬念让我们 总看不见结局 一阵阵风超越了我而我却不能超越这片水域 一尾思念的鱼缓缓从深水中游来","categories":[{"name":"article","slug":"article","permalink":"https://tyale.github.io/categories/article/"}],"tags":[{"name":"随笔","slug":"随笔","permalink":"https://tyale.github.io/tags/随笔/"}]},{"title":"单例设计模式的N种Java实现方法","slug":"单例设计模式的N种Java实现方法","date":"2018-01-17T14:30:32.000Z","updated":"2018-01-18T15:40:32.363Z","comments":true,"path":"2018/01/17/单例设计模式的N种Java实现方法/","link":"","permalink":"https://tyale.github.io/2018/01/17/单例设计模式的N种Java实现方法/","excerpt":"​ 总所周知经典的饱汉式和饿汉式都有可能在多线程环境下产生问题，本文即是探讨各种单例的生成方式和特定条件下可能产生的问题。","text":"​ 总所周知经典的饱汉式和饿汉式都有可能在多线程环境下产生问题，本文即是探讨各种单例的生成方式和特定条件下可能产生的问题。 特点​ 单例模式的特点： ​ 1、只能有一个实例； ​ 2、必须自己创建自己的一个实例； ​ 3、必须给所有其他对象提供这一实例。 饿汉式单例模式​ 也称为预先加载法，实现方式如下： 12345678910111213public class Single &#123; private Single() &#123; System.out.println(&quot;ok&quot;); &#125; private static class InstanceHolder &#123; private static final Single instance = new Single(); &#125; public static Single getInstance() &#123; return InstanceHolder.instance; &#125;&#125; 优点：线程安全，调用时反应速度快，在类加载的同时已经创建好了一个静态对象（创建的唯一对象）； 缺点：资源利用效率不高，可能该实例并不需要，但也被系统加载了。另外，饿汉式在一些场景下是无法使用的，比如，如果Single实例的创建依赖参数或配置文件，则在getInstance()之前必须调用某个方法来设置这些参数，但在设置之前，可能已经new了Single实例，这种情况下，饿汉式的写法是无法使用的。 懒汉式单例模式​ 也称为延迟加载法，实现方式如下 12345678910111213public class LazySingleton &#123; private static LazySingleton instance; private LazySingleton() &#123; &#125; public static LazySingleton getInstance() &#123; if (instance == null) &#123; instance = new LazySingleton(); &#125; return instance; &#125;&#125; ​ 延迟加载法在适用于单线程环境，它不是线程安全的，引入多线程时，就必须通过同步来保护getInstance（）方法，否则可能会返回LazySingleton的两个不同实例。比如，一个线程在判断instance为null后，还没来得及创建新的instance，另一个线程此时也判断到instance为null，这样两个线程便会创建两个LazySingleton实例。 ​ 可以将getInstance（）方法改为同步方法，这样便可以避免上述问题，改进后的单例模式实现如下： 12345678910111213class LazySingleton &#123; private static LazySingleton instance; private LazySingleton() &#123; &#125; public static synchronized LazySingleton getInstance() &#123; if (instance == null) &#123; instance = new LazySingleton(); &#125; return instance; &#125;&#125; ​ 优点：资源利用率高,不执行getInstance就不会被实例。 ​ 缺点：第一次加载时反应不快，多线程使用不必要的同步开销大 ​ 这里的缺点主要是：每次调用getInstance（）方法时，都要同步，而且很多时候的同步是没必要的，这将会极大地拖垮性能（尤其在需要多次调用getInstance方法的地方，当第一次创建了LazySingleton实例后，instance便不再为null，这样后面每次调用getInstance进入方法体后，却便发现自己什么也不用做，而每次调用getInstnce都要同步，需要切换到内核，这样便很浪费资源，每次做很大开销进入方法体，却发现自己什么也不用做）。 DCL单例模式​ 针对延迟加载法的同步实现所产生的性能低的问题，我们可以采用DCL，即双重检查加锁（Double Check Lock）的方法来避免每次调用getInstance（）方法时都同步。实现方式如下： 1234567891011121314151617class LazySingleton &#123; private static LazySingleton instance; private LazySingleton() &#123; &#125; public static LazySingleton getInstance() &#123; if (instance == null) &#123; synchronized (LazySingleton.class) &#123; if (instance == null) &#123; instance = new LazySingleton(); &#125; &#125; &#125; return instance; &#125;&#125; ​ 优点：资源利用率高,不执行getInstance就不会被实例，多线程下效率高。 ​ 缺点：第一次加载时反应不快，由于java 内存模型一些原因偶尔会失败，在高并发环境下也有一定的缺陷，虽然发生概率很小。 ​ DCL对instance进行了两次null判断，第一层判断主要是为了避免不必要的同步，第二层的判断则是为了在null的情况下创建实例。 ​ 对于DCL的不安全性，我们来看看如下场景： ​ 假设线程A执行到instance = new LazySingleton()这句，这里看起来是一句话，但实际上它并不是一个原子操作，我们只要看看这句话被编译后在JVM执行的对应汇编代码就发现，这句话被编译成8条汇编指令，大致做了3件事情： 1.给LazySingleton的实例分配内存。 2.初始化LazySingleton()的构造器 3.将instance对象指向分配的内存空间（注意到这步instance就非null了）。 ​ 但是，由于Java编译器允许处理器乱序执行，以及JDK1.5之前JMM（Java Memory Medel，即Java内存模型）中Cache、寄存器到主内存回写顺序的规定，上面的第二点和第三点的顺序是无法保证的，也就是说，执行顺序可能是1-2-3也可能是1-3-2，如果是后者，并且在3执行完毕、2未执行之前，被切换到线程B上，这时候instance因为已经在线程A内执行过了第三点，instance已经是非空了，所以线程B直接拿走instance，然后使用，然后顺理成章地报错，而且这种难以跟踪难以重现的错误很可能会隐藏很久。 ​ DCL的写法来实现单例是很多技术书、教科书（包括基于JDK1.4以前版本的书籍）上推荐的写法，实际上是不完全正确的。的确在一些语言（譬如C语言）上DCL是可行的，但这取决于是否能保证2、3步的顺序。在JDK1.5之后，官方已经注意到这种问题，调整了JMM、具体化了volatile关键字，因此如果JDK是1.5或之后的版本，只需要将instance的定义改成“private volatile static LazySingleton instance = null;”就可以保证每次都去instance都从主内存读取，就可以使用DCL的写法来完成单例模式。当然volatile或多或少也会影响到性能，最重要的是我们还要考虑JDK1.4以及之前的版本，所以本文中单例模式写法的改进还在继续。 static内部类单例模式​ 该方法是为了解决DCL方法在并发环境中的缺陷而提出的，关于DCL在并发编程中存在的问题可以参考这篇文章：http://blog.csdn.net/ns_code/article/details/17348313的后半部分，其实现方式如下： 12345678910111213class Single &#123; private Single() &#123; System.out.println(&quot;ok&quot;); &#125; private static class InstanceHolder &#123; private static final Single instance = new Single(); &#125; public static Single getInstance() &#123; return InstanceHolder.instance; &#125;&#125; ​ 优点：线程安全，资源利用率高,不执行getInstance就不会被实例。 ​ 缺点：第一次加载时反应不快。 ​ 这里针对最后一种方法补充以下基本知识点：类级内部类（有static修饰的成员内部类）相当于其外部类的成员，只有在第一次使用时才会被装载，而不会在类加载器加载其外部类的时候被装载，而且只会被加载一次。因此，资源利用率高。 ​ 总结：在Java中由于会涉及到并发编程，考虑到效率、安全性等问题，一般常用饿汉式单例模式或static内部类单例模式，而后者又是最优且最常用的单例设计模式的实现方法。","categories":[{"name":"development","slug":"development","permalink":"https://tyale.github.io/categories/development/"}],"tags":[{"name":"单例","slug":"单例","permalink":"https://tyale.github.io/tags/单例/"},{"name":"设计模式","slug":"设计模式","permalink":"https://tyale.github.io/tags/设计模式/"},{"name":"技术","slug":"技术","permalink":"https://tyale.github.io/tags/技术/"}]},{"title":"懂了遗憾，就懂了人生","slug":"懂了遗憾，就懂了人生","date":"2018-01-17T14:30:32.000Z","updated":"2018-01-18T17:09:44.148Z","comments":true,"path":"2018/01/17/懂了遗憾，就懂了人生/","link":"","permalink":"https://tyale.github.io/2018/01/17/懂了遗憾，就懂了人生/","excerpt":"许多事情总是想象比现实更美，相逢如是，离别亦如是，当现实的情形不按照理想的情形发展，事实出现与心愿不统一的结局时，遗憾便产生了。遗憾可以彰显出悲壮之情，而悲壮又给后人留下一种永恒的力量，也许生活带走了太多东西，可是却留下片片真情。有过遗憾的人，必定是感觉到深切的痛苦的人，这样的人也必定真实的活过，付出过最真的心，用自己的行动演绎过至真至纯的情感，令人心动和感慨。","text":"许多事情总是想象比现实更美，相逢如是，离别亦如是，当现实的情形不按照理想的情形发展，事实出现与心愿不统一的结局时，遗憾便产生了。遗憾可以彰显出悲壮之情，而悲壮又给后人留下一种永恒的力量，也许生活带走了太多东西，可是却留下片片真情。有过遗憾的人，必定是感觉到深切的痛苦的人，这样的人也必定真实的活过，付出过最真的心，用自己的行动演绎过至真至纯的情感，令人心动和感慨。 错过的一切如同错过的时光一样，无法找回，只是错过一点点，就会错过太多，或许还会错过一辈子，留下终身的遗憾，有时我们本可以轻易地拥有，然而却让它悄然溜走了，记得以前看过一部电视剧《半生缘》，不否认男女主人公是真心相爱的，但命运与缘分的捉弄使他们各奔东西，多年以后他们再次相见，痛苦万分，追悔不及，只剩遗憾，也许世间最大的悲剧莫过于两个相恋的人不能牵手一生一世，但是正因为有了遗憾，那份情义才越发显得弥足珍贵，既浸入骨髓又超然永恒。又如梁山伯与祝英台的爱情故事，如若他们真的走到了一起，朝朝与暮暮，相伴一生，白头偕老了，那又何来千古绝唱的凄婉？ 不必再去说割舍不下什么，因为已经没有选择的余地了，美好的东西总是太多，我们不可能全部都得到，但对于已经不属于自己的东西，不必再奢望什么，无缘的人总是留下遗憾，在那一个个熟悉的画面里，凋零着各种情绪的味道，在那一个个生动的故事里，多想为它画上一个省略号，却在命运的无奈中被迫为它画下句号，于万丈红尘中的空望，洗却铅华之后的暗伤，将永远与对方形同陌路。 其实有许多感情从开始到结束，不管结果如何，我想只要有过这种让自己曾有过让心灵为之震动的感觉，这本来就是一种富有，一个温暖的感情矿藏，一种生命中最厚重的拥有，毕竟曾经交换过彼此的快乐和寂寞，不要再难过，人总得去面对醒来的一切。人世本无常，岁月流逝如梦一场，曾经的梦想和誓言如落叶般随风飘荡到不知名的地方，但我始终相信当初说它的时候是发自内心的。 很喜欢听徐誉腾演唱的《等一分钟》这首歌，或许是因为那种遗憾中透着丝丝伤感的歌词更打动我心，“如果生命，没有遗憾，没有波澜，你会不会，永远没有说再见的一天，可能年少的心太柔软，经不起风经不起浪，若今天的我能回到昨天，我会向自己妥协，我在等一分钟，或许下一分钟，看到你闪躲的眼，我不会让伤心的泪挂满你的脸；我在等一分钟，或许下一分钟，如果你真的也心痛，我会告诉你我的胸膛依旧暖，那一年我不会让离别成永远。”是的，明明知道你的胸膛依旧暖，可是现在那份温暖已属于另外一个人了。 有的时候，真的幻想时光可以重来一次，那样的话就可以重新选择一切，面对相同的时间里发生的相同的故事不会再重蹈覆辙，不会再走这样的心路，可是想过没有，如果没有经历过遗憾，又怎么能懂得珍惜？如果不是遗憾，又怎么可以那么刻骨铭心，又铭心刻骨的去记住一个人？有许多事必须要亲身经历过才会懂，有了遗憾，才有了可以回忆的片段，才有了令我们一生也无法忘怀的东西，它会在内心深处产生共鸣． 在每个人的工作、生活、学习中都会或多或少的遗憾，我想没有几个人会喜欢它，但是它确确实实又是生命中的收获，可以入心且无声，象长了翅膀，在偌大的心灵世界里自由飞翔。它可以是美好的回忆，也可以是痛苦的煎熬，带给人的是对生命更多、更深刻的感悟。没有经历过遗憾的人生是不完整的，遗憾是一种感人的美，一种破碎的美，因为有它，人世间一切的真善美将更值得称颂；因为有它，生命将更值得去回味；因为有它，就有了远走天涯的念想。 生命只是沧海之一栗，然而却承载了太多的情非得已，聚散离首，不甘心也好，不情愿也罢，生活一直都是一个任人想象的谜，因为不知道最终的谜底，也只能一步步地向前走。人生中也会遇到很多感人的缘分，不经意间的萍水相逢，却发现也可以给予很多，简单的邂逅和错过，也可以在心中烙下清晰的标记。一切渐渐远去，心渐渐冰凉，纵然撕去伪装出的冷漠，找寻你走过的凌乱足迹，想起你曾经的一点一滴，如今只剩下了什么，你的影子徘徊在脑海，我怎么能忘记你曾经给过我美丽？ 懂了遗憾，就懂了人生，在经历以后，我们才会学到了许多，明白了许多，也成熟了许多。人生之路，一定不会总有枝繁叶茂的树，鲜艳夺目的花朵，蝶飞蜂舞的美好景色，它一定也会有阻挡在前的高山和荒凉的沙漠；一定不会总有阳光照耀下缤纷的色彩，也会有阴天时的迷雾重重；生活不仅有灿烂的笑颜，还会有无言的泪水，任谁也无法轻松的跨越。 懂了遗憾，就懂了人生，遗憾是人生的必历之路，但还是希望大家都能少一点遗憾，尤其希望两个真心相爱的人能幸福长久的生活在一起。人生没有完美，生活也没有完美，遗憾和残缺始终都会存在，穿越过岁月的风雨，才发觉已经失去的东西很珍贵，没有得到的东西也很珍贵，但世间最珍贵的还是去把握现在，去珍惜这似水的流年，即使将来容颜不在，至少还可以对自己说：“我有遗憾，但是遗憾过后，我曾坚定的好好生活过，我不后悔。”","categories":[{"name":"article","slug":"article","permalink":"https://tyale.github.io/categories/article/"}],"tags":[{"name":"随笔","slug":"随笔","permalink":"https://tyale.github.io/tags/随笔/"}]}]}